# [These are  tests of Learn C the hard way.](https://www.cntofu.com/book/25/index.html)
---
> 本次学习主要为YSYX复习C语言相关知识

> 学习任务：练习0到练习18， 练习32，练习33，练习42，练习44 需要完成编程算法以及附加题.
---
## 练习0：准备
安装必要的编译环境工具
```bash
$ sudo apt-get install build-essential
```

## 练习1：启用编译器
ex1: Hello World打印程序

## 练习2：用Make来代替Python
* 使用make的第一阶段就是用它已知的方式来构建程序。Make预置了一些知识，来从其它文件构建多种文件。
  * 如：`$ make ex1`
* Makefile简单编写，添加默认参数`CFLAGS=-Wall -g`，添加`all:`和`clean:`

## 练习3：格式化输出
printf的格式化占位符和转义序列,转义序列类似`\n`或者`\r`，格式化占位符类似`%s`或者`%d`

## 练习4：Valgrind 介绍
* 安装 Valgrind,用curl网络问题导致下载不完整时，可换wget
* 使用方法： `$ valgrind ./ex4`

## 练习5：一个C程序的结构
对ex5.c进行逐行讲解

## 练习6：变量类型
* 整数:使用int声明，使用%d来打印。

* 浮点:使用float或double声明，使用%f来打印。

* 字符:使用char来声明，以周围带有'（单引号）的单个字符来表示，使用%c来打印。

* 字符串(字符数组):使用char name[]来声明，以周围带有"的一些字符来表示，使用%s来打印。
> 注：C语言中区分单引号的char和双引号的char[]或字符串。

## 练习7：更多变量和一些算术练习7：更多变量和一些算术
* 使用%ld打印出这个变量，我们添加了个修饰符到%d上面。添加的"l"表示将它当作长整形打印。
* 使用了%%（两个百分号）来打印一个%字符。
* 以特殊的语法'\0'声明了一个字符。这样创建了一个“空字节”字符，实际上是数字0。
* 使用%e以科学记数法的形式打印。

## 练习8：大小和数组
* 使用sizeof关键字来问C语言这些东西占多少个字节。

## 练习9：数组和字符串
* 对C语言来说，字符数组和字符串没有什么不同。

## 练习10：字符串数组和循环
for循环的格式是这样的：
```c 
for(INITIALIZER; TEST; INCREMENTER) {
    CODE;
}
```
下面是for循环的工作机制：
* INITIALIZER中是用来初始化循环的代码，这个例子中它是i = 0。
* 接下来会检查TEST布尔表达式，如果为false（0）则跳过CODE，不做任何事情。
* 执行CODE，做它要做的任何事情。
* 在CODE执行之后会执行INCREMENTER部分，通常情况会增加一些东西，比如这个例子是i++。
* 然后跳到第二步继续执行，直到TEST为false（0）为止。
## 练习11：While循环和布尔表达式
你可以看到while循环的语法更加简单：
```c
while(TEST) {
    CODE;
}
```
* 在C语言中，实际上没有真正的“布尔”类型，而是用一个整数来代替，0代表false，其它值代表true。上一个练习中表达式i < argc实际上值为1或者0，并不像Python是显式的Ture或者False。这是C语言更接近计算机工作方式的另一个例子，因为计算机只把值当成数字。

## 练习12：If，Else If，Else
if语句的格式为：
```c
if(TEST) {
    CODE;
} else if(TEST) {
    CODE;
} else {
    CODE;
}
```
## 练习13：Switch语句
这是对swicth语句工作原理的一个深究，然而实际操作中你只需要记住下面几条简单的原则：
* 总是要包含一个default:分支，可以让你接住被忽略的输入。
* 不要允许“贯穿”执行，除非你真的想这么做，这种情况下最好添加一个//fallthrough的注释。
* 一定要先编写case和break，再编写其中的代码。
* 如果能够简化的话，用if语句代替。

## 练习14：编写并使用函数
* ex14.c:5-6
 告诉C语言你稍后会在你的程序中使用一些函数，它们实际上并没有被定义。这叫做“前向声明”，它解决了要想使用函数先要定义的鸡和蛋的问题。

## 练习15：指针，可怕的指针
* ex15.c:24 创建了一个指向ages的指针。注意int *创建“指向整数的指针”的指针类型的用法。它很像char *，意义是“指向字符的指针”，而且字符串是字符的数组。是不是很相似呢？
* ex15.c:25 创建了指向names的指针。char *已经是“指向char的指针”了，所以它只是个字符串。你需要两个层级，因为names是二维的，也就是说你需要char **作为“指向‘指向字符的指针’的指针”。把它学会，并且自己解释它。

### 实用的指针用法
你可以用指针做下面四个最基本的操作：
* 向OS申请一块内存，并且用指针处理它。这包括字符串，和一些你从来没见过的东西，比如结构体。
* 通过指针向函数传递大块的内存（比如很大的结构体），这样不必把全部数据都传递进去。
* 获取函数的地址用于动态调用。
* 对一块内存做复杂的搜索，比如，转换网络套接字中的字节，或者解析文件。
对于你看到的其它所有情况，实际上应当使用数组。在早期，由于编译器不擅长优化数组，人们使用指针来加速它们的程序。然而，现在访问数组和指针的语法都会翻译成相同的机器码，并且表现一致。由此，你应该每次尽可能使用数组，并且按需将指针用作提升性能的手段。
### 指针词库
现在我打算向你提供一个词库，用于读写指针。当你遇到复杂的指针语句时，试着参考它并且逐字拆分语句（或者不要使用这个语句，因为有可能并不好）：
```c
type *ptr   // type类型的指针，名为ptr。
*ptr        // ptr所指向位置的值。
*(ptr + i)  // ptr所指向位置加上i）的值。
            // 译者注：以字节为单位的话，应该是ptr所指向的位置再加上sizeof(type) * i。
&thing      // thing的地址。
type *ptr = &thing  // 名为ptr，type类型的指针，值设置为thing的地址。
ptr++       // 自增ptr指向的位置。
```
## 练习16：结构体和指向它们的指针
* 使用`malloc`可以从原始内存中构造结构体
* `assert` 断言一个表达式是否正确。
* 使用`x->y`语法来初始化`struct Person`的每个成员，它指明了所初始化的成员。`x->y`是`(*x).y`的简写。
* 使用`strdup`来复制字符串`name`，是为了确保结构体真正拥有它。`strdup`的行为实际上类似`malloc`但是它同时会将原来的字符串复制到新创建的内存。
* 如果定义了创建函数，那么一定需要一个销毁函数，它会销毁`Person`结构体。我再一次使用了`assert`来确保不会得到错误的输入。接着我使用了`free`函数来交还通过`malloc`和`strdup`得到的内存。如果你不这么做则会出现“内存泄露”。
> 译者注：不想显式释放内存又能避免内存泄露的办法是引入`libGC`库。你需要把所有的`malloc`换成`GC_malloc`，然后把所有的`free`删掉。

### 解释结构体
如果你完成了我要求的任务，你应该理解了结构体。不过让我来做一个明确的解释，确保你真正理解了它。

C中的结构体是其它数据类型（变量）的一个集合，它们储存在一块内存中，然而你可以通过独立的名字来访问每个变量。它们就类似于数据库表中的一行记录，或者面向对象语言中的一个非常简单的类。让我们以这种方式来理解它：

* 在上面的代码中，你创建了一个结构体，它们的成员用于描述一个人：名称、年龄、体重、身高。
* 每个成员都有一个类型，比如是int。
* C会将它们打包到一起，于是它们可以用单个的结构体来存放。
* struct Person是一个复合类型，这意味着你可以在同种表达式中将其引用为其它的数据类型。
* 你可以将这一紧密的组合传递给其它函数，就像Person_print那样。
* 如果结构体是指针的形式，接着你可以使用x->y通过它们的名字来访问结构体中独立的部分。
* 还有一种创建结构体的方法，不需要指针，通过x.y来访问。你将会在附加题里面见到它。
如果你不使用结构体，则需要自己计算出大小、打包以及定位出指定内容的内存片位置。实际上，在大多数早期（甚至现在的一些）的汇编代码中，这就是唯一的方式。在C中你就可以让C来处理这些复合数据类型的内存构造，并且专注于和它们交互。

### 附加题
> 参考https://blog.csdn.net/weixin_44781508/article/details/131557669
* 直接在main函数中创建了两个结构体变量joe和frank，并使用点操作符（.）来初始化结构体成员。然后，我们通过将结构体作为参数传递给Person_print函数来打印结构体的内容。
* 为什么之前需要 struct Person *who = malloc(sizeof(struct Person));申请内存，void Person_print(struct Person who)不用分配内存？
  * 在之前的代码中，struct Person who = malloc(sizeof(struct Person));语句是用于动态分配内存，以创建一个指向 struct Person 结构体的指针，并在堆上分配内存空间来存储结构体的实际数据。这是因为函数 Person_create 创建了一个新的 struct Person 结构体，并返回一个指向该结构体的指针。
  * 而在函数 Person_print 中，参数 struct Person who 是通过值传递（pass by value）的方式传入的。这意味着在调用函数时，会将结构体的副本传递给函数，而不是直接传递结构体本身。因此，在函数内部，使用的是副本的数据，而不是原始结构体的数据。由于副本是在栈上创建的，不需要动态分配内存。
  * 在 Person_create 函数中，我们动态分配了内存，因为我们需要在堆上创建一个新的结构体，并返回指向该结构体的指针。在 Person_print 函数中，我们使用了结构体的副本，而不是指针，因此在栈上创建的结构体副本会被传递给函数，并在函数结束后自动被销毁，无需手动释放内存。这种方式可以避免手动分配和释放内存的麻烦，但需要注意副本的创建和传递可能会占用更多的内存空间，尤其是对于大型结构体。如果结构体很大或需要频繁传递，可能需要考虑使用指针传递来避免复制大量数据。

## 练习17：堆和栈的内存分配
### 堆和栈的内存分配
对于现在你们这些年轻人来说，编程简直太容易了。如果你玩玩Ruby或者Python的话，只要创建对象或变量就好了，不用管它们存放在哪里。你并不关心它们是否存放在栈上或堆上。你的编程语言甚至完全不会把变量放在栈上，它们都在堆上，并且你也不知道是否是这样。

然而C完全不一样，因为它使用了CPU真实的机制来完成工作，这涉及到RAM中的一块叫做栈的区域，以及另外一块叫做堆的区域。它们的差异取决于取得储存空间的位置。

堆更容易解释，因为它就是你电脑中的剩余内存，你可以通过malloc访问它来获取更多内存，OS会使用内部函数为你注册一块内存区域，并且返回指向它的指针。当你使用完这片区域时，你应该使用free把它交还给OS，使之能被其它程序复用。如果你不这样做就会导致程序“泄露”内存，但是Valgrind会帮你监测这些内存泄露。

栈是一个特殊的内存区域，它储存了每个函数的创建的临时变量，它们对于该函数为局部变量。它的工作机制是，函数的每个函数都会“压入”栈中，并且可在函数内部使用。它是一个真正的栈数据结构，所以是后进先出的。这对于main中所有类似char section和int id的局部变量也是相同的。使用栈的优点是，当函数退出时C编译器会从栈中“弹出”所有变量来清理。这非常简单，也防止了栈上变量的内存泄露。

理清内存的最简单的方式是遵守这条原则：如果你的变量并不是从malloc中获取的，也不是从一个从malloc获取的函数中获取的，那么它在栈上。

下面是三个值得关注的关于栈和堆的主要问题：

* 如果你从malloc获取了一块内存，并且把指针放在了栈上，那么当函数退出时，指针会被弹出而丢失。
* 如果你在栈上存放了大量数据（比如大结构体和数组），那么会产生“栈溢出”并且程序会中止。这种情况下应该通过malloc放在堆上。
* 如果你获取了指向栈上变量的指针，并且将它用于传参或从函数返回，接收它的函数会产生“段错误”。因为实际的数据被弹出而消失，指针也会指向被释放的内存。
这就是我在程序中使用Database_open来分配内存或退出的原因，相应的Database_close用于释放内存。如果你创建了一个“创建”函数，它创建了一些东西，那么一个“销毁”函数可以安全地清理这些东西。这样会更容易理清内存。

最后，当一个程序退出时，OS会为你清理所有的资源，但是有时不会立即执行。一个惯用法（也是本次练习中用到的）是立即终止并且让OS清理错误。
## 练习18：函数指针

